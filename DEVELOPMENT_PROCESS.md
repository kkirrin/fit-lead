# Процесс разработки приложения FitLead

Этот документ кратко описывает ключевые решения, инструменты и сложности в процессе создания проекта.

## 1. Подход и архитектура

Основной целью было создание качественного MVP с чистой и масштабируемой архитектурой.

*   **Структура:** Выбран монорепозиторий (`backend`, `frontend`) для удобства разработки. На бэкенде применена классическая структура `models/controllers/routes`.
*   **Особенность:** Исходное поле `referralLink` было разделено на `referralCode` (для отслеживания) и `originalUrl` (для редиректа). Это делает систему более гибкой и соответствующей лучшим практикам.

## 2. Использование AI-инструментов

Проект был разработан с активным использованием современных AI-ассистентов для ускорения и повышения качества кода.

*   **Основная среда разработки:** **Cursor IDE** использовалась как основная среда, что позволило бесшовно интегрировать AI-возможности в процесс написания и рефакторинга кода.
*   **Языковая модель:** В качестве основной модели использовалась **Google Gemini**, интегрированная в Cursor.
*   **Задачи, где AI был эффективен:**
    *   **Генерация Boilerplate-кода:** С помощью Gemini были быстро сгенерированы Mongoose-схемы, Express-контроллеры и роуты.
        *   **Пример промпта:** `Create an Express controller for a Product model with CRUD operations (get, create, update, delete). Use async/await and handle errors.`
    *   **Рефакторинг и оптимизация:** Cursor IDE использовался для рефакторинга компонентов React. Например, для улучшения читаемости кода, отладки багов, верстки разметки.
    *   **Написание сложных запросов:** Gemini помог составить сложный Aggregation Pipeline запрос для MongoDB для сбора статистики по кликам.
        *   **Пример промпта:** `Write a MongoDB aggregation pipeline to group Clicks by day for the last 7 days and count them.`
*   **Инженерный контроль:** Несмотря на высокую эффективность AI, проектирование архитектуры, отладка специфических ошибок (связанных с Docker или Next.js) и финальное ревью кода оставались под полным контролем инженера.

## 3. Основные сложности и их решения

1.  **Переменные окружения в Next.js:** Клиентская часть не видела переменные из `.env`.
    *   **Решение:** Использован файл `.env.local` и префикс `NEXT_PUBLIC_` для переменных, предназначенных для браузера.
2.  **Отладка API:** Несоответствие имен полей между фронтендом и бэкендом.
    *   **Решение:** Улучшена обработка ошибок в `catch` блоках на бэкенде для возврата осмысленных сообщений, что значительно ускорило отладку.

## 4. Возможные улучшения

При наличии дополнительного времени, проект можно было бы развить:
*   Внедрить полноценную **JWT-аутентификацию**.
*   Покрыть ключевую бизнес-логику **unit-тестами**.
*   Добавить более строгую **валидацию данных** на бэкенде.
*   Оптимизировать запросы к БД с помощью **индексов**.
